/// handle_cascade()
// returns true when cascade is complete.

ogm_assert(object_index == objPlayField, "handle_scroll must be called from objPlayField")

// check if anything falls.
var fall_coords;
var fall_coords_c = 0;
var next_row_fall_array;
next_row_fall_array[m_width - 1] = 0;
for (var _y = objControl.m_generated_to; _y --> (m_top + 1);)
{
    for (var _x = 0; _x < m_width; ++_x)
    {
        var type = get_grid_at(_x, _y);
        var empty = type == 0 || next_row_fall_array[_x];
        next_row_fall_array[_x] = 0;

        // check for fall above.
        if (empty)
        {
            var can_fall = get_block_can_fall(_x, _y - 1);
            if (can_fall)
            {
                // check the above block is able to fall.
                // mark the block below it for falling.
                fall_coords[fall_coords_c++] = [_x, _y];
                next_row_fall_array[_x] = 1;
                set_grid_at(_x, _y - 1, get_grid_at(_x, _y - 1) | K_FALL_MARKER)
            }
        }
    }
}

if (fall_coords_c > 0)
{
    // perform cascades.
    for (var i = 0; i < fall_coords_c; ++i)
    {
        var arr = fall_coords[i];
        var _x = arr[0];
        var _y = arr[1];
        var btype = get_grid_at(_x, _y -1);

        // drop and remove fall marker
        // clear above block.
        set_grid_at(_x, _y - 1, 0);
        set_grid_at(
            _x, _y,
            btype & ~K_FALL_MARKER,
            K_CAMERA_RIGID
        );

        if (!K_CAMERA_RIGID)
        {
            // scroll camera
            var scroll_dst = _y - m_cascade_scroll_margin
            if (!m_mode_cascade_enable_scroll)
            {
                m_mode_cascade_enable_scroll = true;
                m_mode_cascade_scroll_y = scroll_dst;
            }
            else
            {
                m_mode_cascade_scroll_y = max(
                    m_mode_cascade_scroll_y,
                    scroll_dst
                )
            }
        }
    }
}
else
{
    return true;
}

return false;
