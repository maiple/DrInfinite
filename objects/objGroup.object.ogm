# object

# event create -----------------------------------------------------------------

m_pid = 0;
m_width = 10;
m_hview = 20;
m_top = 0;
m_yview = 0;
m_scroll_yview_dst = 0

m_grid = 0; // index [y, x]
m_init = false;

m_blocks = 0;

enum Mode
{
    waitdrop,
    drop,
    garbage,
    cascade,
    clear,
    scroll
}

m_mode = Mode.waitdrop
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = [0, 0]
m_drop_x = 0
m_drop_y = 0
m_drop_spin = 0 // 0,2: vertical; 1,3: horizontal
m_drop_tick = 0 // for falling time
m_drop_tick_interval = 16;
m_view_margin = 7
m_drop_scroll_margin = 9;
m_cascade_scroll_margin = 11;
m_scroll_y = 0 // fractional-point component of scroll only.
m_drop_spin_timer = 0;
m_emph_timer = 0;

# event step -------------------------------------------------------------------

handle_clear_animation();

if (objControl.m_victory >= 0)
{
    exit;
}

if (m_next_drop_offset < 0)
{
    m_next_drop_offset += 2;
}

if (m_emph_timer > 0)
{
    m_emph_timer--;
    exit;
}

switch (m_mode)
{
case Mode.waitdrop:
    m_mode_wait_timer++
    m_next_drop_offset = m_mode_wait_timer * K_GRID_SIZE * 1.5 / 8;
    if (m_mode_wait_timer >= 8)
    {
        m_mode = Mode.drop;
        m_drop_spin_bonus_time = false;
        m_drop_spin_timer = 0;
        m_mode_wait_timer = 0;
        m_drop_x = m_width div 2 - 1
        m_drop_y = m_yview
        m_drop_spin = 1
        m_drop = m_next_drop;
        m_next_drop = get_drop(m_drop_index++);
        m_next_drop_offset = -32;
    }
    break;
case Mode.drop:
    event_user(1)
    break;
case Mode.cascade:
    m_cascade_timer++;
    if (m_cascade_timer % 8 == 1)
    {
        if (handle_cascade())
        {
            m_mode = Mode.clear;
            m_mode_scroll_timer = 0;

            // don't scroll.
            break;
        }
    }
    handle_scroll();
    break;
case Mode.clear:
    if (handle_clears())
    {
        m_mode = Mode.scroll
        handle_scroll();
    }
    else
    {
        // some clears occurred.
        m_mode = Mode.cascade;
        m_mode_cascade_enable_scroll = false;
        m_emph_timer = 32;
        m_cascade_timer = 0;

        // check for victory
        if (m_virus_count <= 0)
        {
            objControl.m_victory = m_pid;
            objControl.m_victory_timer = 200;
        }
    }
    break;
case Mode.scroll:
    if (handle_scroll())
    {
        m_mode = Mode.waitdrop;
        m_mode_wait_timer = 0;
    }
    break;
}

# event draw -------------------------------------------------------------------------

if (!m_init) exit;

ogm_gpu_enable_scissor(
    x, y, x + m_width * K_GRID_SIZE, y + m_hview * K_GRID_SIZE
);

draw_set_colour(c_grey)
if (objControl.m_victory == m_pid)
{
    draw_set_colour(c_ltgrey);
}
draw_rectangle(0, 0, room_width, room_height, false);

draw_set_colour(c_white)

// draw board
for (var i = m_yview; i < m_yview + m_hview + 2; ++i)
{
    for (var j = 0; j < m_width; ++j)
    {
        draw_block(
            x + K_GRID_SIZE * j, y + K_GRID_SIZE * (i - m_yview - m_scroll_y),
            get_grid_at(j, i)
        );
    }
}

// draw drop
if (m_mode == Mode.drop)
{
    for (var _i = 0; _i < 2; ++_i)
    {
        var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
        var _x = arr[0], _y = arr[1];

        var _x_draw = x + K_GRID_SIZE * _x;
        var _y_draw = y + K_GRID_SIZE * (_y - m_yview - m_scroll_y)

        draw_block(
            _x_draw,
            _y_draw,
            m_drop[_i],
            true // highlight
        );

        if (m_drop_spin_timer != 0 && _i == 0)
        {
            var subimage = clamp(floor(abs(m_drop_spin_timer) * 3), 0, 2);

            var angle = 90 * (m_drop_spin - 1);
            var yscale = -sign(m_drop_spin_timer);

            draw_sprite_ext(
                sprBlockRotationBlur, subimage,
                _x_draw + K_GRID_SIZE / 2,
                _y_draw + K_GRID_SIZE / 2,
                1, yscale, angle, get_block_colour(m_drop[1]), 1
            );

            draw_sprite_ext(
                sprBlockRotationBlur, subimage,
                _x_draw + K_GRID_SIZE / 2,
                _y_draw + K_GRID_SIZE / 2,
                1, yscale, angle, c_white, 0.5
            );
        }
    }
}

draw_clear_animation();

ogm_gpu_disable_scissor();

// draw next block
var _draw_next_x = x + K_GRID_SIZE * (m_width div 2 - 1);
var _draw_next_y = y - K_GRID_SIZE * 1.5 + m_next_drop_offset;
for (var i = 0; i < 2; ++i)
{
    draw_block(_draw_next_x + i * K_GRID_SIZE, _draw_next_y, m_next_drop[i]);
}

# event user1 ------------------------------------------------------------------
/// advance tick during drop

// handle rotation

var spin = global.key_pressed[m_pid, K_KEY_SPINL] - global.key_pressed[m_pid, K_KEY_SPINR]
var successful_spin = false;

if (spin != 0)
{
    var dst_spin = positive_modulo(m_drop_spin + spin, 4);
    if (get_drop_free(m_drop_x, m_drop_y, spin + m_drop_spin))
    {
        m_drop_spin = dst_spin;
        successful_spin = true;
    }
    else
    {
        // move slightly away from rotation direction
        var _xo_sign = (dst_spin >= 2)
            ? 1
            : -1;
        if (get_drop_free(m_drop_x + _xo_sign, m_drop_y, spin + m_drop_spin))
        {
            m_drop_x += _xo_sign;
            m_drop_spin = dst_spin;
            successful_spin = true;
        }
    }
}

if (abs(m_drop_spin_timer) > 0.1)
{
    m_drop_spin_timer -= sign(m_drop_spin_timer) * 0.1;
}
else
{
    m_drop_spin_timer = 0;
}

if (successful_spin)
{
    // motion blur
    m_drop_spin_timer = spin;

    // give bonus time for movement
    if (!m_drop_spin_bonus_time)
    {
        m_drop_tick = floor(min(m_drop_tick, m_drop_tick_interval / 2));
        m_drop_spin_bonus_time = true;
    }

    // orient drop
    m_drop[0] &= ~K_BLOCK_ROTATION;
    m_drop[1] &= ~K_BLOCK_ROTATION;
    switch(m_drop_spin)
    {
    case 0:
        m_drop[0] |= K_BLOCK_ROTATION_DOWN;
        m_drop[1] |= K_BLOCK_ROTATION_UP;
        break;
    case 1:
        m_drop[0] |= K_BLOCK_ROTATION_RIGHT;
        m_drop[1] |= K_BLOCK_ROTATION_LEFT;
        break;
    case 2:
        m_drop[0] |= K_BLOCK_ROTATION_UP;
        m_drop[1] |= K_BLOCK_ROTATION_DOWN;
        break;
    case 3:
        m_drop[0] |= K_BLOCK_ROTATION_LEFT;
        m_drop[1] |= K_BLOCK_ROTATION_RIGHT;
        break;
    }
}

// handle x movement
var xmove = global.key_pressed[m_pid, K_KEY_RIGHT] - global.key_pressed[m_pid, K_KEY_LEFT]
if (xmove != 0 && get_drop_free(m_drop_x + xmove, m_drop_y, m_drop_spin))
{
    m_drop_x += xmove;
}

// handle y movement
m_drop_tick++
var interval = (global.key_down[m_pid, K_KEY_DOWN])
    ? m_drop_tick_interval div 4
    : m_drop_tick_interval;
if (m_drop_tick >= interval || global.key_pressed[m_pid, K_KEY_DOWN])
{
    m_drop_spin_bonus_time = false;
    m_drop_tick = 0;
    if (get_drop_free(m_drop_x, m_drop_y + 1, m_drop_spin))
    {
        m_drop_y++;
    }
    else
    {
        // not free; apply drop to grid.
        for (var _i = 0; _i < 2; ++_i)
        {
            var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
            var _x = arr[0], _y = arr[1];
            set_grid_at(_x, _y, m_drop[_i])
        }

        m_mode = Mode.cascade;
        m_mode_cascade_enable_scroll = false;
        m_cascade_timer = 0;

        // don't scroll.
        exit;
    }
}

handle_scroll();

# event user0 ------------------------------------------------------------------
/// start a new round

// clear grid

m_top = 0;
m_grid = 0;
m_scroll_yview_dst = 0;
m_yview = 0;

// initialize grid as empty.
for (var i = 0; i < m_width; ++i)
{
    for (var j = m_top; j < m_top + m_hview; ++j)
    {
        m_grid[j - m_top, i] = 0
    }
}

m_virus_count = 0;

m_mode = Mode.waitdrop;
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = 0
m_scroll_y = 0
m_clears = 0;
m_clears_c = 0;
m_emph_timer = 0;

m_init = true;

// bottomless mode without this.
m_enable_bottom = true;
m_bottom = m_yview + m_hview;

// get the next drop
m_next_drop = get_drop(m_drop_index++)
m_next_drop_offset = -8;

// remember previous block for high yview.
m_drop_high_hysteresis = 0
m_drop_high_hysteresis_type = 0
