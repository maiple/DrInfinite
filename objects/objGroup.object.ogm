# object

# event create -----------------------------------------------------------------

m_pid = 0;
m_width = 10;
m_hview = 20;
m_top = 0;
m_yview = 0;
m_scroll_yview_dst = 0

m_grid = 0; // index [y, x]
m_init = false;

m_blocks = 0;

enum Mode
{
    waitdrop,
    drop,
    garbage,
    cascade,
    scroll
}

m_mode = Mode.waitdrop
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = [0, 0]
m_drop_x = 0
m_drop_y = 0
m_drop_spin = 0 // 0,2: vertical; 1,3: horizontal
m_drop_tick = 0 // for falling time
m_drop_tick_interval = 16;
m_view_margin = 7
m_drop_scroll_margin = 9;
m_scroll_y = 0 // fractional-point component of scroll only.

# event step -------------------------------------------------------------------

switch (m_mode)
{
case Mode.waitdrop:
    m_mode_wait_timer++
    if (m_mode_wait_timer >= 8)
    {
        m_mode = Mode.drop;
        m_mode_wait_timer = 0;
        set_drop()
    }
    break;
case Mode.drop:
    event_user(1)
    break;
case Mode.cascade:
    if (m_cascade_timer++ % 5 == 3)
    {
        if (handle_cascade())
        {
            m_mode = Mode.scroll;
            m_mode_scroll_timer = 0;
            break;
        }
    }
    handle_scroll();
    break;
case Mode.scroll:
    if (handle_scroll())
    {
        m_mode = Mode.waitdrop;
        m_mode_wait_timer = 0;
    }
    break;
}

# event draw -------------------------------------------------------------------------

if (!m_init) exit;

// draw board
for (var i = m_yview; i < m_yview + m_hview; ++i)
{
    for (var j = 0; j < m_width; ++j)
    {
        draw_block(
            x + K_GRID_SIZE * j, y + K_GRID_SIZE * (i - m_yview - m_scroll_y),
            m_grid[i - m_top, j]
        );
    }
}

// draw drop
if (m_mode == Mode.drop)
{
    for (var _i = 0; _i < 2; ++_i)
    {
        var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
        var _x = arr[0], _y = arr[1];
        draw_block(
            x + K_GRID_SIZE * _x,
            y + K_GRID_SIZE * (_y - m_yview - m_scroll_y),
            m_drop[_i]
        );
    }
}

# event user1 ------------------------------------------------------------------
/// advance tick during drop

// handle rotation

var spin = global.key_pressed[m_pid, K_KEY_SPINL] - global.key_pressed[m_pid, K_KEY_SPINR]

if (spin != 0)
{
    if (get_drop_free(m_drop_x, m_drop_y, spin + m_drop_spin))
    {
        m_drop_spin = positive_modulo(m_drop_spin + spin, 4)
    }
    else
    {
        // move in 2 directions
        for (var _xo = -1; _xo <= 1; ++_xo)
        {
            var _xo_sign = (m_drop_spin >= 2)
                ? _xo
                : -_xo;
            if (get_drop_free(m_drop_x + _xo_sign, m_drop_y, spin + m_drop_spin))
            {
                m_drop_x += _xo_sign;
                m_drop_spin = positive_modulo(m_drop_spin + spin, 4)
            }
        }

        // TODO: try moving around in 4 directions?
    }
}

// handle x movement
var xmove = global.key_pressed[m_pid, K_KEY_RIGHT] - global.key_pressed[m_pid, K_KEY_LEFT]
if (xmove != 0 && get_drop_free(m_drop_x + xmove, m_drop_y, m_drop_spin))
{
    m_drop_x += xmove;
}

// handle y movement
m_drop_tick++
var interval = (global.key_down[m_pid, K_KEY_DOWN])
    ? m_drop_tick_interval div 4
    : m_drop_tick_interval;
if (m_drop_tick >= interval || global.key_pressed[m_pid, K_KEY_DOWN])
{
    m_drop_tick = 0;
    if (get_drop_free(m_drop_x, m_drop_y + 1, m_drop_spin))
    {
        m_drop_y++;
    }
    else
    {
        // not free; apply drop to grid.
        for (var _i = 0; _i < 2; ++_i)
        {
            var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
            var _x = arr[0], _y = arr[1];
            set_grid_at(_x, _y, m_drop[_i])
        }

        m_mode = Mode.cascade;
        m_cascade_timer = 0;
    }
}

handle_scroll();

# event user0 ------------------------------------------------------------------
/// start a new round

// clear grid

m_top = 0;
m_grid = 0;
m_scroll_yview_dst = 0;
m_yview = 0;

// initialize grid as empty.
for (var i = 0; i < m_width; ++i)
{
    for (var j = m_top; j < m_top + m_hview; ++j)
    {
        m_grid[j - m_top, i] = 0
    }
}

m_mode = Mode.waitdrop;
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = [0, 0]
m_scroll_y = 0

m_init = true;

// remember previous block for high yview.
m_drop_high_hysteresis = 0
m_drop_high_hysteresis_type = 0
