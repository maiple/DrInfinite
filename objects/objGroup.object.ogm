# object

# event create -----------------------------------------------------------------

m_pid = 0;
m_width = 10;
m_hview = 20;
m_top = 0;
m_yview = 0;
m_scroll_yview_dst = 0
m_top_garbage = 0;
m_slide_time = 0;

m_grid = 0; // index [y, x]
m_init = false;

m_blocks = 0;

enum Mode
{
    waitdrop,
    drop,
    garbage,
    events,
    cascade,
    clear,
    scroll
}

m_mode = Mode.waitdrop
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = [0, 0]
m_drop_x = 0
m_drop_y = 0
m_drop_spin = 0 // 0,2: vertical; 1,3: horizontal
m_drop_tick = 0 // for falling time
m_drop_tick_interval_max = 16;
m_drop_tick_interval = m_drop_tick_interval_max;
m_view_margin = 5;
m_drop_scroll_margin = 5;
m_cascade_scroll_margin = 11;
m_scroll_y = 0 // fractional-point component of scroll only.
m_drop_spin_timer = 0;
m_emph_timer = 0;
m_cascade_interval = 8;

# event step -------------------------------------------------------------------

handle_clear_animation();

if (objControl.m_victory >= 0)
{
    exit;
}

if (m_next_drop_offset < 0)
{
    m_next_drop_offset += 2;
}

if (m_wait_down_scroll_timer > 0 && global.key_down[m_pid, K_KEY_DOWN])
{
    m_wait_down_scroll_timer--;
    exit;
}
else
{
    m_wait_down_scroll_timer = 0;
}

if (m_emph_timer > 0)
{
    m_emph_timer--;
    exit;
}

switch (m_mode)
{
case Mode.waitdrop:
    m_mode_wait_timer++
    m_next_drop_offset = m_mode_wait_timer * K_GRID_SIZE * 1.5 / 8;

    if (m_mode_wait_timer >= 8)
    {
        m_mode = Mode.drop;
        m_hold_timer = 0;
        m_drop_spin_bonus_time = false;
        m_drop_spin_timer = 0;
        m_mode_wait_timer = 0;
        m_drop_x = m_width div 2 - 1
        m_drop_y = m_yview
        m_drop_spin = 1
        m_drop_spin_max_y = m_drop_y;
        m_drop = m_next_drop;
        m_slide_time = 0;
        m_slide_rotation_bonus = 0;
        m_next_drop = get_drop(m_drop_index++);
        m_next_drop_offset = -32;
        m_previous_top = get_top();
    }
    break;
case Mode.drop:
    event_user(1)
    break;
case Mode.events:
    if (handle_events())
    {
        m_mode = Mode.cascade;
        m_clear_groups = [undefined];
    }
    if (m_mode != Mode.cascade)
    {
        break;
    }
    m_mode_cascade_enable_scroll = false;
    m_cascade_timer = 0;
    // fallthrough
case Mode.cascade:
    m_cascade_timer++;
    if (m_cascade_timer % m_cascade_interval == 1)
    {
        if (handle_cascade())
        {
            m_mode = Mode.clear;
            m_mode_scroll_timer = 0;

            // don't scroll.
            break;
        }
    }
    handle_scroll();
    break;
case Mode.clear:
    if (!handle_clears())
    {
        // some clears occurred.
        m_mode = Mode.cascade;
        m_mode_cascade_enable_scroll = false;
        m_emph_timer = 32;
        m_cascade_timer = 0;

        // check for victory
        if (m_virus_count <= 0)
        {
            objControl.m_victory = m_pid;
            objControl.m_victory_timer = 200;
            m_emph_timer += 16;
            play_sound(sfxVictory);
        }
        break;
    }
    else
    {
        // No additional clears occurred -- check for combos.
        if (m_clear_groups_c >= 2)
        {
            // details of the combo.
            var x_sum = 0;
            var types_c = 0;
            var types;

            // discern combo details from clear group information.
            for (var i = 0; i < m_clear_groups_c; ++i)
            {
                var group = m_clear_groups[i];
                // group is [type, length, xstart]
                types[types_c++] = group[0];
                x_sum += group[2];
            }

            // apply garbage to other groups.
            with (objGroup)
            {
                if (m_pid != other.m_pid)
                {
                    m_garbage_buffer[m_garbage_buffer_c++] = [x_sum, types];
                }
            }

            play_sound(sfxCombo);
        }

        m_clear_groups_c = 0;
    }

    // clears complete.
    // if holding down, add a pause before scrolling up, to aid player visually.
    m_mode = Mode.scroll;
    var scroll_up_distance = m_yview - max(get_top(), m_previous_top) + m_view_margin;
    if (scroll_up_distance > 0 && global.key_down[m_pid, K_KEY_DOWN])
    {
        m_wait_down_scroll_timer = 120;
        break;
    }
    // fallthrough
case Mode.scroll:
    if (handle_scroll())
    {
        // switch to garbage mode if needed
        // otherwise go to waitdrop.
        if (m_garbage_buffer_c >= 1)
        {
            m_mode = Mode.garbage;
            m_garbage_drops_c = 0;
            m_garbage_timer = 0;
        }
        else
        {
            m_mode = Mode.waitdrop;
            m_mode_wait_timer = 0;
        }
    }
    break;
case Mode.garbage:
    // TODO
    if (m_garbage_timer == 0)
    {
        // initialize
        var garbage = m_garbage_buffer[m_garbage_buffer_c - 1];
        var x_sum = garbage[0];
        var types = garbage[1];
        var types_c = array_length_1d(types);

        var x_interval = m_width div types_c;

        // the possible phase shifts permitted given the intervals defined.
        var x_margin = (m_width - x_interval * types_c) + x_interval;

        // phase offset.
        var x_offset = x_sum mod max(1, x_margin);

        m_garbage_drops_c = 0;
        for (var i = 0; i < types_c; ++i)
        {
            var _x = x_offset + x_interval * i;
            var _y = m_yview;
            var type = types[i];
            m_garbage_drops[m_garbage_drops_c++] = [type, _x, _y];
        }

        // pop garbage from buffer.
        m_garbage_buffer_c--;
    }

    if (m_garbage_timer++ % m_cascade_interval == 0)
    {
        if (handle_garbage_drop())
        {
            // finished garbage drop.
            m_mode = Mode.cascade;

            // initialize cascade
            // FIXME: this initialization should be automatic somehow.
            m_mode_cascade_enable_scroll = false;
            m_cascade_timer = 0;
        }
    }
    handle_scroll();
    break;
}

# event draw -------------------------------------------------------------------------

if (!m_init) exit;

var _xs = (window_get_width() / room_width)
var _ys = (window_get_height() / room_height)

ogm_gpu_enable_scissor(
    x * _xs, y * _ys,
    (x + m_width * K_GRID_SIZE) * _xs,
    (y + m_hview * K_GRID_SIZE) * _ys
);

draw_set_colour(c_grey)
if (objControl.m_victory == m_pid)
{
    draw_set_colour(c_ltgrey);
}
draw_rectangle(0, 0, room_width, room_height, false);

draw_set_colour(c_white)

// draw board
for (var i = m_yview; i < m_yview + m_hview + 2; ++i)
{
    for (var j = 0; j < m_width; ++j)
    {
        draw_block(
            x + K_GRID_SIZE * j, y + K_GRID_SIZE * (i - m_yview - m_scroll_y),
            get_grid_at(j, i)
        );
    }
}

// draw drop
if (m_mode == Mode.drop)
{
    for (var _i = 0; _i < array_length_1d(m_drop); ++_i)
    {
        var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
        var _x = arr[0], _y = arr[1];

        var _x_draw = x + K_GRID_SIZE * _x;
        var _y_draw = y + K_GRID_SIZE * (_y - m_yview - m_scroll_y)

        draw_block(
            _x_draw,
            _y_draw,
            m_drop[_i],
            true // highlight
        );

        if (m_drop_spin_timer != 0 && _i == 0 && array_length_1d(m_drop) > 1)
        {
            var subimage = clamp(floor(abs(m_drop_spin_timer) * 3), 0, 2);

            var angle = 90 * (m_drop_spin - 1);
            var yscale = -sign(m_drop_spin_timer);

            draw_sprite_ext(
                sprBlockRotationBlur, subimage,
                _x_draw + K_GRID_SIZE / 2,
                _y_draw + K_GRID_SIZE / 2,
                1, yscale, angle, get_block_colour(m_drop[1]), 1
            );

            draw_sprite_ext(
                sprBlockRotationBlur, subimage,
                _x_draw + K_GRID_SIZE / 2,
                _y_draw + K_GRID_SIZE / 2,
                1, yscale, angle, c_white, 0.5
            );
        }
    }
}

// draw garbage

if (m_mode == Mode.garbage)
{
    for (var _i = 0; _i < m_garbage_drops_c; ++_i)
    {
        var garbage = m_garbage_drops[_i];
        var type = garbage[0], _x = garbage[1], _y = garbage[2];

        if (is_undefined(type)) continue;

        var _x_draw = x + K_GRID_SIZE * _x;
        var _y_draw = y + K_GRID_SIZE * (_y - m_yview - m_scroll_y)

        draw_block(
            _x_draw,
            _y_draw,
            type,
            true // highlight
        );
    }
}

draw_clear_animation();

ogm_gpu_disable_scissor();

// draw next block
var _draw_next_x = x + K_GRID_SIZE * (m_width div 2 - 1);
var _draw_next_y = y - K_GRID_SIZE * 1.5 + m_next_drop_offset;
for (var i = 0; i < array_length_1d(m_next_drop); ++i)
{
    draw_block(_draw_next_x + i * K_GRID_SIZE, _draw_next_y, m_next_drop[i]);
}

// draw virus count
draw_set_colour(c_white);
draw_set_valign(fa_bottom);
draw_text(x, y - 6, string(m_virus_count));

# event user1 ------------------------------------------------------------------
/// advance tick during drop

// set m_drop_tick_interval

m_drop_tick_interval = round((m_drop_tick_interval_max) / (1 + m_drop_index / 140));
if (m_drop_tick_interval < 9)
{
    m_drop_tick_interval = 9;
}

// handle rotation

var spin = global.key_pressed[m_pid, K_KEY_SPINL] - global.key_pressed[m_pid, K_KEY_SPINR]
var successful_spin = handle_spin(spin);

if (successful_spin)
{
    if (m_slide_time > 0)
    {
        m_slide_rotation_bonus = 4;
    }
}

if (abs(m_drop_spin_timer) > 0.1)
{
    m_drop_spin_timer -= sign(m_drop_spin_timer) * 0.1;
}
else
{
    m_drop_spin_timer = 0;
}

if (successful_spin)
{
    play_sound(sfxSpin);

    // motion blur
    m_drop_spin_timer = spin;

    // give bonus time for movement
    if (!m_drop_spin_bonus_time)
    {
        m_drop_tick = floor(min(m_drop_tick, m_drop_tick_interval / 2));
        m_drop_spin_bonus_time = true;
    }

    // orient drop
    if (!is_string(m_drop[0]))
    {
        m_drop[0] &= ~K_BLOCK_ROTATION;
        m_drop[1] &= ~K_BLOCK_ROTATION;
        switch(m_drop_spin)
        {
        case 0:
            m_drop[0] |= K_BLOCK_ROTATION_DOWN;
            m_drop[1] |= K_BLOCK_ROTATION_UP;
            break;
        case 1:
            m_drop[0] |= K_BLOCK_ROTATION_RIGHT;
            m_drop[1] |= K_BLOCK_ROTATION_LEFT;
            break;
        case 2:
            m_drop[0] |= K_BLOCK_ROTATION_UP;
            m_drop[1] |= K_BLOCK_ROTATION_DOWN;
            break;
        case 3:
            m_drop[0] |= K_BLOCK_ROTATION_LEFT;
            m_drop[1] |= K_BLOCK_ROTATION_RIGHT;
            break;
        }
    }
}

// handle x movement
var xmove = global.key_pressed[m_pid, K_KEY_RIGHT] - global.key_pressed[m_pid, K_KEY_LEFT]
var xhold = global.key_down[m_pid, K_KEY_RIGHT] - global.key_down[m_pid, K_KEY_LEFT];

var force_move = 0;
if (xhold != 0)
{
    if (m_hold_timer-- < 0)
    {
        m_hold_timer = 4;
        force_move = true;
    }
}

if ((xmove != 0 || force_move) && get_drop_free(m_drop_x + xhold, m_drop_y, m_drop_spin))
{
    m_drop_x += xhold;
    play_sound(sfxMove);

    if (xmove != 0)
    {
        m_hold_timer = 16;
    }
}

// handle y movement
m_drop_tick++
var interval = (global.key_down[m_pid, K_KEY_DOWN])
    ? m_drop_tick_interval div 4
    : m_drop_tick_interval;
var fastdrop = global.key_pressed[m_pid, K_KEY_DOWN];
var interval_elapsed = m_drop_tick >= interval

var slide_time_max = interval + 6 + m_slide_rotation_bonus;

var drop_obstructed = !get_drop_free(m_drop_x, m_drop_y + 1, m_drop_spin);

if (drop_obstructed)
{
    // not free.
    m_drop_spin_bonus_time = false;
    m_drop_tick = 0;
    m_drop_tick = 0;

    // allow some extra sliding time.
    if (m_slide_time++ >= slide_time_max)
    {
        // not free; apply drop to grid.
        for (var _i = 0; _i < array_length_1d(m_drop); ++_i)
        {
            var arr = get_drop_position(m_drop_x, m_drop_y, m_drop_spin, _i);
            var _x = arr[0], _y = arr[1];
            set_grid_at(_x, _y, m_drop[_i])
        }

        m_mode = Mode.events;

        // play sound
        play_sound(sfxLand);

        // don't scroll.
        exit;
    }
}
else if (interval_elapsed || fastdrop)
{
    // shift drop down (standard falling behaviour).
    m_drop_y++;
    m_drop_spin_max_y = m_drop_y;
    m_drop_spin_bonus_time = false;
    m_drop_tick = 0;
    m_slide_time = 0;
    m_slide_rotation_bonus = 0;
}

handle_scroll();

# event user0 ------------------------------------------------------------------
/// start a new round

// clear grid

m_top = 0;
m_grid = 0;
m_scroll_yview_dst = 0;
m_yview = 0;

// initialize grid as empty.
for (var i = 0; i < m_width; ++i)
{
    for (var j = m_top; j < m_top + m_hview; ++j)
    {
        m_grid[j - m_top, i] = 0
    }
}

m_virus_count = 0;

m_mode = Mode.waitdrop;
m_mode_wait_timer = 0;
m_drop_index = 0;
m_drop = [0, 0]; // an array of numbers or strings (e.g. "bomb")
m_events_c = 0;
m_scroll_y = 0
m_extra_clears_c = 0;
m_clears = [undefined]; // individual tiles cleared
m_clears_c = 0;
m_clear_groups = [undefined]; // rows/columns cleared. Stored as [type, length, x]
m_clear_groups_c = 0;
m_emph_timer = 0;
m_garbage_buffer_c = 0;

m_init = true;
m_hold_timer = 0;

// bottomless mode without this.
m_enable_bottom = true;
m_bottom = m_yview + m_hview;

// get the next drop
m_next_drop = get_drop(m_drop_index++)
m_next_drop_offset = -8;

m_bomb_index = 0;

m_wait_down_scroll_timer = 0;

// remember previous block for high yview.
m_drop_high_hysteresis = 0
m_drop_high_hysteresis_type = [0, 0]
m_drop_high_hysteresis_bomb_redo = false;
